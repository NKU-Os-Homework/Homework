# Lab5

## 练习1：加载应用程序并执行

### 设计实现过程

SSTATUS_SPP 、 SSTATUS_SPIE 和 SSTATUS_SIE 是 RISC-V 架构中的位掩码。

+ SSTATUS_SPP表示之前的特权模式
+ SSTATUS_SPIE表示在发生异常或中断之前的中断使能状态
+ SSTATUS_SIE表示当前的监管态中断使能状态

将`tf->gpr.sp`设置为用户栈的栈顶
`tf->epc`为用户程序的入口地址
`tf->status`是通过判断前面几个掩码来进行赋值的。

### 用户态进程运行过程

在`proc_init`中，会创建`idle`作为初始进程，然后会创建一个`init_main`进程。在`init_main`中，创建了一个用户进程`user_main`，这个创建使用了函数`kernel_thread`，这个函数是用于创建内核进程的，它会初始化一个临时的 `trapframe` 结构体，将线程的入口函数和参数设置到 `trapframe` 中，然后调用 `do_fork` 函数创建内核进程。在`do_fork`中，会设置当前进程(`init_main`)作为`user_main`的父进程，并将新创建的进程唤醒(设置状态为`PROC_RUNNABLE`)，且将新进程放置在可运行的链表内。创建`user_main`用户进程成功后，会通过`while`循环调用函数`schedule`来切换可执行的用户进程。直到所有用户进程都运行结束，`while`循环结束且用户进程结束。

## 练习2：父进程复制自己的内存空间给子进程

### 设计实现过程

首先通过`page2kva(page)`和`page2kva(npage)`获得被复制页的虚拟地址和目标页面的虚拟地址。然后通过`memcpy(kva_dst, kva_src, PGSIZE)`进行内容的复制。然后将复制得到的页面设置到对应的`PTE`中。

### 实现Copy on Write机制

+ **概念**
  + 写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。

+ **实现**
  + 如果实现COW的话，需要维护一个COW标志位，表示该页表是否使用了COW。然后禁止对该页表进行写操作。
  + 在`fork`过程中，不直接将父进程的页表内容复制给子进程，而是将父进程的页表项指针给子进程，并且在父进程的页表的引用次数+1，这样可以实现多个进程共用一块数据，减少内存开销。
  + 当不同进程进行写操作时，会单独为该进程进行复制操作，然后在复制出来的新的页面上进行写操作，防止影响其他进程的使用。
  + 为了防止页表被提前回收，需要维护引用次数。

## 练习3：理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

+ `fork`

  + 使用 `alloc_proc()` 函数分配一个新的 `proc_struct` 结构体。如果分配失败，跳转到 `fork_out`，返回错误码 `-E_NO_FREE_PROC`。

  + 使用 `setup_kstack()` 函数为子进程分配内核栈。如果分配失败，跳转到 `bad_fork_cleanup_proc`，释放先前分配的 `proc_struct` 结构体，并返回错误码 `-E_NO_MEM`。

  + 使用 `copy_mm()` 函数复制或共享父进程的内存空间给子进程。

  + 使用 `copy_thread()` 函数在子进程的内核栈上设置 `trapframe（tf）`和上下文信息。

  + 设置子进程的父进程为当前进程（父进程）。确保当前进程的 `wait_state` 为0，表明当前进程没有在等待其他进程。

  + 调用`get_pid()`获取一个唯一的进程标识符（PID）给子进程。

  + 使用 `hash_proc()` 函数将子进程加入到进程表的哈希表中。
  + 使用 `set_links()` 函数设置进程间的关系。

  + 通过 `local_intr_save` 和 `local_intr_restore` 来开关中断。
  + 将子进程的状态设置为 `PROC_RUNNABLE`，表示子进程可以运行了。

  + 将子进程的 PID 作为 `do_fork` 函数的返回值。

+ `exec`

  + 使用 `user_mem_check` 函数检查 `name` 字符串是否在用户空间合法，并且长度 `len` 是否合法。如果检查失败，返回错误码`-E_INVAL`。

  + 将 `name` 字符串的内容复制到 `local_name` 缓冲区中，以便后续设置新进程的名字。

  + 检查当前进程的 `mm_struct` 是否存在`（mm != NULL）`。如果存在，调用 `exit_mmap` 函数释放当前进程的内存映射空间，并调用 `put_pgdir` 函数释放页目录。最后，调用 `mm_destroy` 函数销毁当前进程的 `mm_struct`。
  + 设置当前进程的 `mm` 为 `NULL`。

  + 调用 `load_icode` 函数，该函数负责根据提供的二进制代码 `binary` 和大小 `size` 来设置新的内存空间，加载新的程序。如果加载失败，跳转到 `execve_exit`，进行处理并返回错误码。

  + 调用 `set_proc_name` 函数，将新的程序名字设置为 `local_name`。

  + 如果整个过程没有出错，返回 `0`，表示 `execve` 成功。

  + 如果加载新程序失败，执行 `do_exit(ret)` 来终止当前进程，并输出错误信息。
  `panic`函数用于在发生致命错误时停止系统的运行，输出错误信息并进入死循环。

+ `wait`
  + 如果 `code_store` 不为 `NULL`，使用 `user_mem_check` 函数检查用户空间的 `code_store` 是否合法。

  + 如果指定了具体的子进程 `PID（pid != 0）`，则通过 `find_proc` 函数在进程表中找到对应的子进程。
  + 如果没有指定子进程 `PID（pid == 0）`，则遍历当前进程的子进程链表，寻找处于 `PROC_ZOMBIE` 状态的子进程。

  + 如果找到了子进程，并且其状态为 `PROC_ZOMBIE`，则跳转到标签 `found`。

  + 如果有子进程，但子进程状态不是 `PROC_ZOMBIE`，将当前进程设置为 `PROC_SLEEPING`，等待子进程状态发生变化。
  + 设置当前进程的 `wait_state` 为 `WT_CHILD`，表示当前进程正在等待子进程的退出。
  + 调用 `schedule()` 进行调度，切换到其他可运行的进程执行。

  + 如果找到了 `PROC_ZOMBIE` 状态的子进程，继续执行，跳转到标签 `found`。

  + 如果找到的子进程是空闲进程或初始化进程，发生 `panic`，因为这两个进程不应该被 `wait`。
  + 如果 `code_store` 不为 `NULL`，将子进程的退出码存储到用户空间。
  + 在禁止中断的情况下，调用 `unhash_proc` 函数将子进程从进程表的哈希表中移除，并调用 `remove_links` 函数断开与父进程和兄弟进程的链接。
  + 恢复中断状态，调用 `put_kstack` 函数释放子进程的内核栈，最后调用`kfree` 函数释放子进程的 `proc_struct`结构体。

  + 返回 `0`，表示 `wait` 调用成功。

+ `exit`

  + 检查当前进程是否是空闲进程或初始化进程。如果是，则发生 `panic`，因为这两个进程不应该退出。

  + 获取当前进程的 `mm_struct`，并检查是否存在。如果存在，调用 `exit_mmap` 释放内存映射空间，调用 `put_pgdir` 释放页目录，最后调用 `mm_destroy` 销毁 `mm_struct`。
  + 确保 `current->mm` 设置为 `NULL`。

  + 将当前进程的状态设置为 `PROC_ZOMBIE`，表示进程已经终止。
  + 设置进程的退出码为传入的错误码 `error_code`。

  + 禁用中断，获取当前进程的父进程指针 `proc`。
  + 如果父进程的等待状态为 `WT_CHILD`，则调用 `wakeup_proc` 唤醒父进程，告知其子进程状态变为 `PROC_ZOMBIE`。

  + 在循环中，处理当前进程的所有子进程，将它们链接到初始化进程`（initproc）`的子进程链表中。
  + 如果子进程的状态为 `PROC_ZOMBIE`，并且初始化进程等待状态为 `WT_CHILD`，则唤醒初始化进程。

  + 恢复中断状态，调用 `schedule` 进行调度，切换到其他可运行的进程执行。
  注意，此时当前进程已经处于 `PROC_ZOMBIE` 状态，即它将不再被调度。

  + 在调度后，发生 `panic`，输出错误信息，表示 `do_exit` 不应该返回。

`fork`和`exec`是在内核态运行的。`wait`和`exit`是在用户态运行的。

用户进程是在用户态运行的，当需要运行内核态指令时，用户进程会通过系统调用来使用内核态函数。

内核态运行结果会通过寄存器或者直接对内存进行修改传递到用户态。

创建进程(通过函数`alloc_proc`创建，状态为`PROC_UNINIT`) -> 设置状态(函数`wakeup_proc`设置状态为`PROC_RUNNABLE`) -> 进程运行(`schedule`函数用于调度) -> 进程结束(调用函数`do_exit`，将状态设置为`PROC_ZOMBIE`) -> 资源回收(父进程`do_wait`等待子进程结束后回收对应的资源)

## Challenge 2

该用户程序是在操作系统编译时链接到内核的，即该用户程序是被包含在操作系统内核中的。常用操作系统的加载中，用户程序通常以可执行文件的形式存储在磁盘上，而在执行时，操作系统的加载器会负责将可执行文件加载到内存中。但由于当前操作系统未实现文件系统，所以只能将用户程序包含在内核中进行运行。
