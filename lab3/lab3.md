# Lab3

## 练习1：理解基于FIFO的页面替换算法

页面换入时：

+ 函数`swap_in`创建一个新的页面`result`，然后设置一个指向该页面的指针
+ 断言`assert(result != NULL)`确定页面是否创建成功
+ 函数`get_pte`获取指向目标虚拟地址的指针
+ 断言`assert(r != 0)`测试是否能够正常读取磁盘数据
+ 函数`swapfs_read`封装`ide_read_secs`，实现读取硬盘数据
+ 函数`ide_read_secs`从对应的硬盘扇区复制数据到页面中
+ 函数`_fifo_map_swappable`会创建一个指针`head`指向当前的队列的首部，创建一个指针指向当前元素的队列指针`pra_page_link`
+ 断言`assert(entry != NULL && head != NULL)`确保`entry`和`head`都不为空，为空表示队列不存在或者插入队里的元素不存在
+ 函数`list_add`封装`list_add_after`将页面`entry`加入到队列队首
+ 函数`list_add_after`封装`_list_add`将元素`elm`加入到链表队列`listelm`中
+ 函数`_list_add`将元素插入，将前一个元素的`next`指针和后一个元素的`prev`指针指向`elm`，然后设置`elm`的`next`和`prev`指针

页面换出时：

+ 函数`swap_out`调用管理器的`swap_out_victim`函数，选择被换出的页面并将地址存储在指针`page`
+ 断言`assert((*ptep & PTE_V) != 0)`判断该页面是否有效
+ 函数`swapfs_write`将页面内容写到磁盘的交换区
+ 管理器的函数`map_swappable`将在写入操作失败时将页面重新设置为可交换
+ 管理器的函数`free_page`将在写入操作成功后将页面释放
+ 函数`tlb_invalidate`可以确保在下次访问任何虚拟地址时，TLB都会重新加载页表项，以获取最新的物理地址映射
+ 函数`_fifo_swap_out_victim`应该从`pra_list_head`队列的最前面取消链接最早到达的页面，然后将该页面的地址设置为`ptr_page`的地址。
+ `assert(head != NULL)`确保队列队头存在，不存在即没有页面
+ `assert(in_tick == 0)`确保当前时钟处于中断时刻，然后再进行页面换出
+ `list_del(entry)`使用该函数将最早的页面从队列中删除
+ `list_del`封装`_list_del`，`_list_del`将前一个元素的`next`指针指向下一个元素，将下一个元素的`prev`指针指向前一个元素

## 练习2：深入理解不同分页模式的工作原理

+ 在RISC-V架构中，有三种页表级别：sv32、sv39和sv48。这些级别决定了虚拟地址和物理地址之间的映射关系。尽管这些级别有所不同，但它们的基本结构和操作方式是相似的，因此这两段代码在形式上相似。第一段代码是用于一级页表项的查找和创建。它首先检查一级页表项的有效位(PTE_V)，如果为0，则表示对应的二级页表不存在，需要进行创建。在创建之前，代码会分配一个新的页面(`alloc_page()`)，并将其引用计数设置为1。然后，通过`page2pa()`获取页面的物理地址，并使用`memset()`将该页面清零。最后，通过`pte_create()`创建一个新的页表项，并将其赋值给一级页表项。第二段代码是用于二级页表项的查找和创建。它首先检查二级页表项的有效位(PTE_V)，如果为0，则表示对应的页表不存在，需要进行创建。在创建之前，代码会分配一个新的页面，并将其引用计数设置为1。然后，通过`page2pa()`获取页面的物理地址，并使用`memset()`将该页面清零。最后，通过`pte_create()`创建一个新的页表项，并将其赋值给二级页表项。
+ 将页表项的查找和分配合并在一个函数中，可以使代码的结构变得简单，也可以在调用时更加方便。但是，这种写法在后续进行功能优化时，难以对单一功能进行修改，对于代码的维护也有一定的影响。将两个功能拆开需要看具体的需求，如果后续有对两个功能分别进行优化的打算，需要将它们分开；如果后续没有相关计划，不分开也不会影响使用。

## 练习3：给未被映射的地址映射上物理页

+ 设计实现过程：
  使用`swap_in`创建一个新的页面，然后通过`page_insert`构建新建页物理地址与线性地址的映射，然后调用`mm`的`swap_map_swappable`将新建页设置为可交换。
+ 潜在用处
访问权限：页目录项和页表项中的权限位可以用于确定页面的访问权限。在页替换算法中，可以根据页面的访问权限来决定是否替换页面，或者在替换页面时更新页面的访问权限。
访问计数：页表项中的访问计数位可以用于记录页面的访问次数。在页替换算法中，可以根据页面的访问计数来确定哪些页面是最近被访问的，从而进行页面替换的决策。
脏位：页表项中的脏位可以用于标记页面是否被修改过。在页替换算法中，可以根据页面的脏位来确定哪些页面是最近被修改过的，从而进行页面替换的决策。
有效位：页目录项和页表项中的有效位可以用于标记页面是否有效。在页替换算法中，可以根据页面的有效位来确定哪些页面是有效的，从而进行页面替换的决策。
+ 硬件应该检查页表项中的有效位，如果有效位为0，表示页面不存在，会触发缺页异常。
硬件会根据页表项中的物理页框号和偏移量计算出物理地址，并尝试访问该物理地址。
如果物理地址无效或者访问权限不符合要求，硬件会触发页访问异常，并将控制权交给操作系统的缺页服务。
  + 数据结构Page的全局变量与页表中的页目录项和页表项有对应关系。每个Page结构体对应一个物理页框，而页表中的页目录项和页表项则记录了物理页框的相关信息，如物理地址、访问权限等。通过Page结构体的索引，可以找到对应的页目录项和页表项，从而获取和修改物理页框的相关信息。

## 练习4：补充完成Clock页替换算法

+ 设计实现过程：
  + `_clock_init_mm`
  使用`list_init`函数初始化`pra_list_head`为空链表。
  然后初始化当前指针`curr_ptr`指向`pra_list_head`，表示当前页面替换位置为链表头
  将`mm`的私有成员指针指向`pra_list_head`，用于后续的页面替换算法操作
  + `_clock_map_swappable`
  获取当前页面的链表成员变量，使用函数`list_add_before`将页面page插入到页面链表`pra_list_head`的末尾
  使用`get_pte`获得页面的虚拟地址，然后将页面的`visited`标志置为1，表示该页面已被访问
  + `_clock_swap_out_victim`
  通过`curr_ptr`遍历页面链表`pra_list_head`，查找最早未被访问的页面
  使用函数`le2page`获取当前页面对应的`Page`结构指针
  如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给`ptr_page`作为换出页面，在此处需要输出`curr_ptr`以通过`make grade`
  使用`get_pte`函数得到虚拟地址，然后如果当前页面已被访问，需要将`visited`标志置为0，表示该页面已被重新访问

+ 工作原理：
  + Clock算法：Clock算法使用一个类似于时钟的数据结构来维护页面的访问情况。它通过一个指针（称为Clock指针）按顺序扫描页面，并根据页面的访问位（或者称为引用位）来决定是否替换页面。如果页面的访问位为1，表示页面最近被访问过，指针会继续向前移动；如果页面的访问位为0，表示页面很久没有被访问过，指针会停在该位置，选择该页面进行替换。
  + FIFO算法：FIFO算法简单地按照页面进入内存的顺序进行替换。它维护一个页面队列，当需要替换页面时，选择队列中最早进入的页面进行替换。
+ 实现复杂度：
  + Clock算法：Clock算法相对于FIFO算法来说，需要维护额外的访问位信息，并且需要进行指针的移动操作。这使得Clock算法的实现相对复杂一些。
  + FIFO算法：FIFO算法相对简单，只需要维护一个页面队列，并按照队列中页面的顺序进行替换。
+ 替换策略：
  + Clock算法：Clock算法根据页面的访问位来决定是否替换页面。如果页面的访问位为1，表示页面最近被访问过，不会被替换；如果页面的访问位为0，表示页面很久没有被访问过，会被选择进行替换。
  + FIFO算法：FIFO算法按照页面进入内存的顺序进行替换，最早进入内存的页面会被选择进行替换。
+ 性能表现：
  + Clock算法：Clock算法相对于FIFO算法来说，更加关注页面的访问情况，可以更好地适应具有局部性的访问模式。因此，在某些情况下，Clock算法的性能可能会比FIFO算法更好。
  + FIFO算法：FIFO算法简单直观，但是它没有考虑页面的访问情况，可能会导致较差的性能，特别是在存在较高的页面访问局部性时。

## 练习5：阅读代码和实现手册，理解页表映射方式相关知识

使用一个大页的好处与优势：

+ 减少页表项数量：使用大页表可以减少页表项的数量，因为一个大页表项可以映射更多的物理页。这样可以减少页表的数量，节省内存空间。
+ 提高访问效率：由于大页表映射更多的物理页，可以减少对页表的访问次数，从而提高内存访问的效率。这是因为在访问大页表时，只需要查找一次页表项即可确定物理页的映射关系，而不需要多次查找多级页表。
+ 提高 TLB 命中率：因为一个大页表项可以映射更多的虚拟页，可以提高 TLB 的命中率。

坏处与风险：

+ 内存碎片化：使用大页表会导致内存碎片化的问题。因为大页表要求连续的物理页来映射一个大页，如果没有足够的连续物理页可用，就无法使用大页表。这可能导致内存碎片化，浪费一些物理内存空间。
+ 内存分配限制：使用大页表可能会限制内存分配的灵活性。由于大页表要求连续的物理页，可能会导致某些内存分配算法无法有效地分配连续的物理页。
+ TLB缺失的代价更高：虽然大页表可以提高TLB的命中率，但当发生TLB缺失时，由于一个大页表项映射更多的虚拟页，需要更多的内存访问来确定物理页的映射关系，这会导致更高的访存延迟。
