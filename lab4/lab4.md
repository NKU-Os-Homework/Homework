# Lab4

## 练习1：分配并初始化一个进程控制块

### 设计实现过程

在代码`alloc_proc`给定区域对`struct proc_struct`的各个变量进行基本的初始化：

+ 设置`state`为`PROC_UNINIT`，标识为未初始化。
+ `pid`设置为`-1`，表示进程的`PID`尚未分配。
+ `runs`运行次数设置为`0`，表示进程尚未运行。
+ `kstack`内核栈指针设置为`0`，表示进程的内核栈尚未分配。
+ `need_resched`设置为`0`，表示进程不需要重新调度。
+ `parent`父进程指针设置为`NULL`，表示进程尚未有父进程。
+ `mm`内存管理结构指针设置为`NULL`，表示进程尚未有内存管理结构。
+ `context`进行`memset`操作，将进程的上下文结构进行内存清零操作，以确保其初始值为`0`。
+ `tf`将进程的中断帧设置为NULL，表示进程尚未有中断帧。
+ 进程的CR3寄存器设置为`boot_cr3`的值，表示进程的页目录表基地址为`boot_cr3`
+ `flags`将进程的标志字段设置为`0`，即标志位未设置。
+ `name`进行`memset`操作，并且以名字长度`PROC_NAME_LEN`为参数，进行内存清零操作，以确保其初始值为空字符串。

### 问题

+ `struct context context`  
**含义**：context是一个结构体，用于保存进程的上下文信息，包括寄存器的值和执行现场的相关信息。
**作用**：当进程被调度执行时，需要保存当前进程的上下文，并在需要切换到其他进程时，恢复相应进程的上下文。context结构体用于保存这些上下文信息，以便在进程切换时进行上下文的保存和恢复。

+ `struct trapframe *tf`
**含义**：保存进程的执行状态，
**作用**：当进程从用户空间跳进内核空间的时候，进程的执行状态被保存在了中断帧中（注意这里需要保存的执行状态数量不同于上下文切换）。系统调用可能会改变用户寄存器的值，我们可以通过调整中断帧来使得系统调用返回特定的值。

## 练习2：为新创建的内核线程分配资源

### 设计实现过程

完善函数`do_fork`，对`alloc_proc`创建的进程进行初始化。

+ 调用`alloc_proc`函数，获得一块进程的信息块`proc`。如果没有分配成功，就跳转到分支`fork_out`，函数直接返回。
+ 调用`setup_kstack`为进程分配一个内核栈。如果分配失败，就跳转到分支`bad_fork_cleanup_kstack`。
+ 从原进程复制内存管理信息到新创建的进程，如果复制没有成功，则跳转到分支`bad_fork_cleanup_proc`。
+ 调用`copy_thread`函数，复制原进程上下文到新进程。
+ 通过调用`local_intr_save`保存当前中断状态，后续`local_intr_restore`根据`intr_flag`决定是否启用中断。
+ 调用函数`hash_proc`将新进程添加到进程列表，同时需要将进程的`list_link`变量加入到链表内。同时，进程计数要增加并要将当前进程`current`设置为进场`proc`的父进程。
+ 调用函数`wakeup_proc`唤醒新进程，即将进程的`state`设置为`PROC_RUNNABLE`。
+ 返回值`ret`设置为新进程号。

### 问题

**函数`get_pid`的实现分析**：

+ 使用静态断言来确保`MAX_PID`大于`MAX_PROCESS`，即进程号的范围要大于进程的最大数量。
+ 定义一个指向`proc_struct`结构体的指针变量`proc`。
+ 定义一个指向进程列表的链表头指针`list`，以及一个用于遍历链表的临时指针`le`。
+ 定义两个静态变量`next_safe`和`last_pid`，分别用于记录下一个安全的进程号和上一个分配的进程号。初始值都设置为`MAX_PID`。
+ 通过`if`判断，如果上一个分配的进程号加1后超过了`MAX_PID`，则将`last_pid`重置为1，并跳转到`inside`标签处。
+ 通过`if`判断，如果上一个分配的进程号大于等于下一个安全的进程号，则执行`inside`标签处的代码。
+ `inside`标签：将下一个安全的进程号设置为`MAX_PID`。
+ 使用`while`循环遍历进程列表，直到遍历完所有的进程。
+ `repeat`标签：进入循环遍历进程链表
+ `while`循环内，先将链表节点转换为进程结构体指针。
+ 判断当前进程的ID等于上一个分配的进程号，则执行以下代码。
+ 如果上一个分配的进程号加`1`后大于等于下一个安全的进程号，需要进行判断上一个分配的进程号是否大于等于`MAX_PID`，如果成立则将`last_pid`重置为`1`。然后，将下一个安全的进程号设置为MAX_PID。跳转到`repeat`标签，重新开始遍历进程列表。
+ 如果当前进程的ID大于上一个分配的进程号，并且下一个安全的进程号大于当前进程的ID，将下一个安全的进程号设置为当前进程的ID。返回上一个分配的进程号作为新的进程号。

根据函数的实现，可以发现每一次分配线程号时，会通过遍历链表，获得一个与当前已有的所有进程不一样的ID，然后将该ID进行返回。所以`ucore`可以做到给每个新fork的线程一个唯一的id。

## 练习3：编写proc_run函数（需要编码）

### 设计实现过程

+ 声明一个`bool`类型的变量`intr_flag`来保存中断状态。
+ 定义两个`struct proc_struct`类型的指针`prev`和`next`，分别指向`current`和`proc`。用来表示当前进程与切换的目标进程。
+ `local_intr_save`通过读取`SSTATUS`寄存器的`SIE`位，保存当前的中断状态，并禁止进行中断。
+ 将全局指针`current`赋值为`proc`，意为当前运行进程为`proc`。
+ 使用函数`lcr3`将页表切换为`proc`的`cr3`。
+ 使用函数`switch_to`，将当前进程的上下文变量与目标进程的上下文变量作为参数，意为从当前进程切换为目标进程。
+ `local_intr_restore`同样是读取`SIE`位，解除中断禁止。

### 问题

一共创建了两个内核线程，分别是`idleproc`和`initproc`。它们是在`proc_init`中创建的。`idleproc`是第一个内核线程，它的`pid`为`0`，状态为`PROC_RUNNABLE`，负责在系统空闲时执行。它的函数入口是`cpu_idle`，在循环中检查当前进程是否需要重新调度，如果需要，则调用`schedule`函数进行进程切换。`initproc`是第二个内核线程，它的`pid`为`1`，状态为`PROC_RUNNABLE`，负责创建用户态的`init_main`线程。它的函数入口是`init_main`，在函数中打印一些信息，并返回`0`。

## Challenge

+ `local_intr_save(intr_flag)`是一个宏定义，将运行一次`__intr_save`函数
+ `__intr_save()`函数通过读取`sstatus`寄存器的值，并与`SSTATUS_SIE`进行按位与操作，来判断中断是否被允许。如果中断被允许，则调用`intr_disable()`函数来禁用中断，并返回`1`；否则返回`0`。
+ `local_intr_restore(intr_flag)`是一个宏定义，将运行一次`__intr_restore`函数
+ `__intr_restore()`函数根据传入的参数`flag`的值来判断是否启用中断。如果`flag`为真（非零），则调用`intr_enable()`函数来启用中断。
